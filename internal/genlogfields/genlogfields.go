package genlogfields

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"runtime/debug"

	logfields "github.com/nvx/go-proto-logfields"
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil // If there are no messages then we should not generate anything.
	}

	filename := file.GeneratedFilenamePrefix + ".logfields.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-gologfields. DO NOT EDIT.")
	if bi, ok := debug.ReadBuildInfo(); ok {
		g.P("// ", bi.Main.Path, " version: ", bi.Main.Version)
	}
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	generateFileContent(file, g)
	return g
}

var (
	fmtPkg       = protogen.GoImportPath("fmt")
	logfieldsPkg = protogen.GoImportPath("github.com/nvx/go-proto-logfields")
)

func generateFileContent(file *protogen.File, g *protogen.GeneratedFile) {
	for _, msg := range file.Messages {
		generateLogHandlers(g, msg)
		generateExtractRequestFields(g, msg)
	}
}

func generateLogHandlers(g *protogen.GeneratedFile, msg *protogen.Message) {
	for _, childMsg := range msg.Messages {
		if !childMsg.Desc.IsMapEntry() {
			generateLogHandlers(g, childMsg)
		}
	}

	g.P("func (m *", msg.GoIdent, ") LogFields() map[string]string {")
	defer func() {
		g.P("}")
		g.P()
	}()

	var (
		complexMessageOrType = len(msg.Oneofs) > 0
		needsBody            bool
	)
	for _, field := range msg.Fields {
		if field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		if field.Desc.Kind() == protoreflect.MessageKind {
			complexMessageOrType = true
			needsBody = true
		} else if log := retrieveLogAnnotation(field.Desc.Options()); log != nil {
			needsBody = true
		}
	}

	if !needsBody {
		g.P("return map[string]string{}")
		return
	}

	g.P("// Handle being called on nil message.")
	g.P("if m == nil {")
	g.P("return map[string]string{}")
	g.P("}")
	g.P()

	if !complexMessageOrType {
		literalsMapVar := generateLogHandlerLiteralsMap(g, msg)
		g.P("return ", literalsMapVar)
	} else {
		generateLogHandlerComplex(g, msg)
	}
}

func generateLogHandlerComplex(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("// Gather fields from oneofs and child messages.")
	g.P("var hasInner bool")
	g.P()

	type mergeMap struct {
		mapVar string
	}
	mapsToMerge := make([]mergeMap, 0, len(msg.Oneofs)+len(msg.Fields))

	for _, oneOf := range msg.Oneofs {
		oneOfMapVar := generateLogHandlerOneOfMap(g, oneOf)
		g.P("hasInner = hasInner || len(", oneOfMapVar, ") > 0")
		g.P()

		mapsToMerge = append(mapsToMerge, mergeMap{
			mapVar: oneOfMapVar,
		})
	}

	for _, field := range msg.Fields {
		// Only handle fields containing nested messages.
		if field.Message == nil || field.Oneof != nil || field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		childMsgMapVar := "childMsgMap" + field.GoName
		g.P(childMsgMapVar, " := ", logfieldsPkg.Ident("ExtractLogFieldsFromMessage"), "(m.", field.GoName, ")")
		g.P("hasInner = hasInner || len(", childMsgMapVar, ") > 0")
		g.P()

		mapsToMerge = append(mapsToMerge, mergeMap{
			mapVar: childMsgMapVar,
		})
	}

	literalsMapVar := generateLogHandlerLiteralsMap(g, msg)

	// If there are no complex field maps to merge than we can return early.
	g.P("if !hasInner {")
	g.P("return ", literalsMapVar)
	g.P("}")
	g.P("")

	for _, mapToMerge := range mapsToMerge {
		g.P("for k, v := range ", mapToMerge.mapVar, " {")
		g.P(literalsMapVar, "[k] = v")
		g.P("}")
		g.P()
	}
	g.P("return ", literalsMapVar)
}

func generateLogHandlerLiteralsMap(g *protogen.GeneratedFile, msg *protogen.Message) string {
	const literalsMapVar = "literalsMap"

	g.P(literalsMapVar, " := map[string]string{")
	for _, field := range msg.Fields {
		if field.Message != nil || field.Oneof != nil {
			continue
		}

		log := retrieveLogAnnotation(field.Desc.Options())
		if log == nil {
			continue
		}
		// NB: See the comment on the 'fieldValue' on why this is so elaborate.
		g.P(append(append([]interface{}{`"`, log.GetName(), `": `}, fieldValue("m", field)...), ",")...)
	}
	g.P("}")
	g.P()

	return literalsMapVar
}

func generateLogHandlerOneOfMap(g *protogen.GeneratedFile, oneOf *protogen.Oneof) string {
	var oneOfMapVar = "oneOfMap" + oneOf.GoName

	g.P("var ", oneOfMapVar, " map[string]string")
	g.P("switch m.", oneOf.GoName, ".(type) {")
	for _, field := range oneOf.Fields {
		log := retrieveLogAnnotation(field.Desc.Options())
		if log == nil && field.Message == nil {
			continue
		}

		g.P("case *", field.GoIdent, ":")
		if field.Message != nil {
			fieldRef := fmt.Sprintf("m.%s.(*%s).%s", oneOf.GoName, field.GoIdent.GoName, field.GoName)
			g.P(oneOfMapVar, " = ", logfieldsPkg.Ident("ExtractLogFieldsFromMessage"), "(", fieldRef, ")")
		} else {
			// NB: See the comment on the 'fieldValue' on why this is so elaborate.
			g.P(append(append([]interface{}{oneOfMapVar, ` = map[string]string{"`, log.GetName(), `": `}, fieldValue("m", field)...), "}")...)
		}
	}
	g.P("default:")
	g.P(oneOfMapVar, " = map[string]string{}")
	g.P("}")

	return oneOfMapVar
}

func generateExtractRequestFields(g *protogen.GeneratedFile, msg *protogen.Message) {
	for _, childMsg := range msg.Messages {
		if !childMsg.Desc.IsMapEntry() {
			generateExtractRequestFields(g, childMsg)
		}
	}

	g.P("func (m *", msg.GoIdent, ") ExtractRequestFields(dst map[string]interface{}) {")
	defer func() {
		g.P("}")
		g.P()
	}()

	g.P("// Handle being called on nil message.")
	g.P("if m == nil {")
	g.P("return")
	g.P("}")

	for _, field := range msg.Fields {
		if field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		log := retrieveLogAnnotation(field.Desc.Options())
		if field.Message == nil && log == nil {
			continue
		}

		g.P()
		if field.Oneof != nil {
			g.P("if _, ok := m.", field.Oneof.GoName, ".(*", field.GoIdent, "); ok {")
		}

		if field.Message != nil {
			g.P(logfieldsPkg.Ident("ExtractRequestFieldsFromMessage"), "(m.Get", field.GoName, "(), dst)")
		} else if log != nil {
			g.P(`dst["`, log.GetName(), `"] = m.Get`, field.GoName, "()")
		}

		if field.Oneof != nil {
			g.P("}")
		}
	}
}

// fieldValue produces a slice that should be fed directly into the generated file's printer method
// `g.P()`. We can not return a string as that would lead the 'GoImportPath.Ident()' method not to
// be handled approriately, producing invalid code and missing import declarations.
func fieldValue(parentStructVar string, field *protogen.Field) []interface{} {
	valueExpr := []interface{}{parentStructVar, ".Get", field.GoName, "()"}
	switch field.Desc.Kind() {
	case protoreflect.BytesKind:
		valueExpr = append([]interface{}{"string("}, valueExpr...)
		valueExpr = append(valueExpr, ")")
	case protoreflect.StringKind:
		if field.Desc.Cardinality() != protoreflect.Repeated {
			// No special casing required for a non-repeated string.
			break
		}
		fallthrough
	default:
		valueExpr = append([]interface{}{fmtPkg.Ident("Sprintf"), `("%v", `}, valueExpr...)
		valueExpr = append(valueExpr, ")")
	}
	return valueExpr
}

func retrieveLogAnnotation(fieldOptions protoreflect.ProtoMessage) *logfields.LogField {
	// The supplied interface might be empty but will still not be comparible to a nil pointer.
	// Hence we assert that the proto message is atleast valid before trying to extract our
	// extension field.
	if !fieldOptions.ProtoReflect().IsValid() {
		return nil
	}

	if proto.HasExtension(fieldOptions, logfields.E_Logfield) {
		logExt, ok := proto.GetExtension(fieldOptions, logfields.E_Logfield).(*logfields.LogField)
		if !ok {
			return nil
		}
		return logExt
	}
	return nil
}
