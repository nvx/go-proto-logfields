package genlogfields

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	logfields "github.com/nvx/go-proto-logfields"
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil // If there are no messages then we should not generate anything.
	}

	filename := file.GeneratedFilenamePrefix + ".logfields.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-gologfields. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	generateFileContent(gen, file, g)
	return g
}

var (
	fmtPkg       = protogen.GoImportPath("fmt")
	stringsPkg   = protogen.GoImportPath("strings")
	logfieldsPkg = protogen.GoImportPath("github.com/nvx/go-proto-logfields")
)

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	for _, msg := range file.Messages {
		generateLogHandlers(g, msg)
		generateExtractRequestFields(g, msg)
	}
}

func generateLogHandlers(g *protogen.GeneratedFile, msg *protogen.Message) {
	for _, childMsg := range msg.Messages {
		if !childMsg.Desc.IsMapEntry() {
			generateLogHandlers(g, childMsg)
		}
	}

	g.P("func (m *", msg.GoIdent, ") LogFields() map[string]string {")
	defer func() {
		g.P("}")
		g.P()
	}()

	var (
		complexMessageOrType bool = len(msg.Oneofs) > 0
		needsBody            bool
	)
	for _, field := range msg.Fields {
		if field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		if field.Desc.Kind() == protoreflect.MessageKind {
			complexMessageOrType = true
			needsBody = true
		} else if log, _ := retrieveLogAnnotation(field.Desc.Options()); log != nil {
			needsBody = true
		}
	}

	if !needsBody {
		g.P("return map[string]string{}")
		return
	}

	g.P("// Handle being called on nil message.")
	g.P("if m == nil {")
	g.P("return map[string]string{}")
	g.P("}")
	g.P()

	if !complexMessageOrType {
		literalsMapVar := generateLogHandlerLiteralsMap(g, msg)
		g.P("return ", literalsMapVar)
	} else {
		generateLogHandlerComplex(g, msg)
	}
}

func generateLogHandlerComplex(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("// Gather fields from oneofs and child messages.")
	g.P("var hasInner bool")
	g.P()

	type mergeMap struct {
		mapVar string
	}
	var mapsToMerge []mergeMap

	for _, oneOf := range msg.Oneofs {
		oneOfMapVar := generateLogHandlerOneOfMap(g, oneOf)
		g.P("hasInner = hasInner || len(", oneOfMapVar, ") > 0")
		g.P()

		mapsToMerge = append(mapsToMerge, mergeMap{
			mapVar: oneOfMapVar,
		})
	}

	for _, field := range msg.Fields {
		// Only handle fields containing nested messages.
		if field.Message == nil || field.Oneof != nil || field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		childMsgMapVar := "childMsgMap" + field.GoName
		g.P(childMsgMapVar, " := ", logfieldsPkg.Ident("ExtractLogFieldsFromMessage"), "(m.", field.GoName, ")")
		g.P("hasInner = hasInner || len(", childMsgMapVar, ") > 0")
		g.P()

		mapsToMerge = append(mapsToMerge, mergeMap{
			mapVar: childMsgMapVar,
		})
	}

	literalsMapVar := generateLogHandlerLiteralsMap(g, msg)

	// If there are no complex field maps to merge than we can return early.
	g.P("if !hasInner {")
	g.P("return ", literalsMapVar)
	g.P("}")
	g.P("")

	for _, mapToMerge := range mapsToMerge {
		g.P("for k, v := range ", mapToMerge.mapVar, " {")
		g.P(literalsMapVar, "[k] = v")
		g.P("}")
		g.P()
	}
	g.P("return ", literalsMapVar)
}

func generateLogHandlerLiteralsMap(g *protogen.GeneratedFile, msg *protogen.Message) string {
	const literalsMapVar = "literalsMap"

	g.P(literalsMapVar, " := map[string]string{")
	for _, field := range msg.Fields {
		if field.Message != nil || field.Oneof != nil {
			continue
		}

		log, _ := retrieveLogAnnotation(field.Desc.Options())
		if log == nil {
			continue
		}
		// NB: See the comment on the 'fieldValue' on why this is so elaborate.
		g.P(append(append([]interface{}{`"`, log.GetName(), `": `}, fieldValue("m", field)...), ",")...)
	}
	g.P("}")
	g.P()

	return literalsMapVar
}

func generateLogHandlerOneOfMap(g *protogen.GeneratedFile, oneOf *protogen.Oneof) string {
	var oneOfMapVar = "oneOfMap" + oneOf.GoName

	g.P("var ", oneOfMapVar, " map[string]string")
	g.P("switch m.", oneOf.GoName, ".(type) {")
	for _, field := range oneOf.Fields {
		log, _ := retrieveLogAnnotation(field.Desc.Options())
		if log == nil && field.Message == nil {
			continue
		}

		g.P("case *", field.GoIdent, ":")
		if field.Message != nil {
			fieldRef := fmt.Sprintf("m.%s.(*%s).%s", oneOf.GoName, field.GoIdent.GoName, field.GoName)
			g.P(oneOfMapVar, " = ", logfieldsPkg.Ident("ExtractLogFieldsFromMessage"), "(", fieldRef, ")")
		} else {
			// NB: See the comment on the 'fieldValue' on why this is so elaborate.
			g.P(append(append([]interface{}{oneOfMapVar, ` = map[string]string{"`, log.GetName(), `": `}, fieldValue("m", field)...), "}")...)
		}
	}
	g.P("default:")
	g.P(oneOfMapVar, " = map[string]string{}")
	g.P("}")

	return oneOfMapVar
}

func generateExtractRequestFields(g *protogen.GeneratedFile, msg *protogen.Message) {
	for _, childMsg := range msg.Messages {
		if !childMsg.Desc.IsMapEntry() {
			generateExtractRequestFields(g, childMsg)
		}
	}

	g.P("func (m *", msg.GoIdent, ") ExtractRequestFields(dst map[string]interface{}) {")
	defer func() {
		g.P("}")
		g.P()
	}()

	g.P("// Handle being called on nil message.")
	g.P("if m == nil {")
	g.P("return")
	g.P("}")

	for _, field := range msg.Fields {
		if field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		log, _ := retrieveLogAnnotation(field.Desc.Options())
		if field.Message == nil && log == nil {
			continue
		}

		g.P()
		if field.Oneof != nil {
			g.P("if _, ok := m.", field.Oneof.GoName, ".(*", field.GoIdent, "); ok {")
		}

		if field.Message != nil {
			g.P(logfieldsPkg.Ident("ExtractRequestFieldsFromMessage"), "(m.Get", field.GoName, "(), dst)")
		} else if log != nil {
			g.P(`dst["`, log.GetName(), `"] = m.Get`, field.GoName, "()")
		}

		if field.Oneof != nil {
			g.P("}")
		}
	}
}

func fieldLocation(fieldStack []*protogen.Field) string {
	var location string
	for idx, field := range fieldStack {
		if idx == 0 {
			location += string(field.Desc.FullName()) + "."
		} else {
			location += string(field.Desc.FullName().Name()) + "."
		}
	}
	return strings.TrimSuffix(location, ".")
}

// fieldValue produces a slice that should be fed directly into the generated file's printer method
// `g.P()`. We can not return a string as that would lead the 'GoImportPath.Ident()' method not to
// be handled approriately, producing invalid code and missing import declarations.
func fieldValue(parentStructVar string, field *protogen.Field) []interface{} {
	valueExpr := []interface{}{parentStructVar, ".Get", field.GoName, "()"}
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		// No special casing required.
	case protoreflect.BytesKind:
		valueExpr = append([]interface{}{"string("}, valueExpr...)
		valueExpr = append(valueExpr, ")")
	default:
		valueExpr = append([]interface{}{fmtPkg.Ident("Sprintf"), `("%v", `}, valueExpr...)
		valueExpr = append(valueExpr, ")")
	}
	return valueExpr
}

func extractionError(fieldName protoreflect.FullName) error {
	return fmt.Errorf("failed to extract log field annotation for field %q", fieldName)
}

func retrieveLogAnnotation(fieldOptions protoreflect.ProtoMessage) (*logfields.LogField, bool) {
	// The supplied interface might be empty but will still not be comparible to a nil pointer.
	// Hence we assert that the proto message is atleast valid before trying to extract our
	// extension field.
	if !fieldOptions.ProtoReflect().IsValid() {
		return nil, true
	}

	if proto.HasExtension(fieldOptions, logfields.E_Logfield) {
		logExt, ok := proto.GetExtension(fieldOptions, logfields.E_Logfield).(*logfields.LogField)
		if !ok {
			return nil, false
		}
		return logExt, true
	}
	return nil, true
}
